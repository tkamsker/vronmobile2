 ✅ All Updates Complete: BlenderAPI Integration

  I've successfully analyzed the existing blenderapi microservice and updated all feature documentation to use it instead of creating new GraphQL mutations. This eliminates ALL backend work - zero new code needed!

  Summary of Changes

  Key Discovery: The existing BlenderAPI microservice at /Users/thomaskamsker/Documents/Atom/vron.one/microservices/blenderapi already implements the complete navmesh generation workflow with a session-based REST API.

  Files Updated

  1. research.md - Decision 4 Replaced

  - ❌ OLD: 2 new GraphQL mutations (generateNavMesh, getNavMeshStatus)
  - ✅ NEW: Reuse existing BlenderAPI REST service
  - Benefits:
    - Zero backend changes required
    - Battle-tested (already deployed to stage)
    - Session-based with automatic cleanup (5-minute TTL)
    - Production-ready error handling and progress tracking

  BlenderAPI Workflow:
  POST /sessions → session_id
  POST /sessions/{id}/upload → upload GLB
  POST /sessions/{id}/navmesh → start generation
  GET /sessions/{id}/status → poll (every 2s)
  GET /sessions/{id}/download/{file} → download result
  DELETE /sessions/{id} → cleanup

  2. contracts/ - GraphQL Replaced with REST

  - ❌ Deleted: navmesh-graphql.md (60+ lines of new GraphQL schema)
  - ✅ Created: blenderapi-rest.md (complete REST API documentation)
  - Includes:
    - All 7 REST endpoints documented
    - Request/response examples
    - Complete Dart service implementation
    - Error handling patterns
    - NavMesh parameters (cell_size, agent_height, etc.)

  3. plan.md - Backend References Updated

  - Updated Technical Context: Added "BlenderAPI microservice (existing REST API for navmesh)"
  - Updated Constitution Check: Changed "Only 2 NEW GraphQL mutations" → "Reuses existing BlenderAPI (ZERO new backend code)"
  - Updated Project Structure: Renamed combined_scan_api_client.dart → blenderapi_service.dart
  - Added test file: blenderapi_service_test.dart

  4. data-model.md - Session-Based Workflow

  - Added field: navmeshSessionId (tracks BlenderAPI session)
  - Added field: combinedGlbLocalPath (downloaded GLB before navmesh)
  - Updated status enum:
    - Added: uploadingToBlender, downloadingNavmesh
    - Clarified: uploadingUsdz, processingGlb
  - Updated state transitions: 8 states instead of 7
  - Updated data flow: Shows complete BlenderAPI session lifecycle

  New Workflow:
  combining → uploadingUsdz → processingGlb → glbReady
    → uploadingToBlender → generatingNavmesh → downloadingNavmesh → completed

  5. quickstart.md - Test Scenarios Updated

  - Updated Scenario 1 (happy path): Shows BlenderAPI upload/download steps
  - Updated Scenario 5 (failure): BlenderAPI error codes and session cleanup
  - Updated Performance Benchmarks: Added BlenderAPI upload/download times
  - Added Troubleshooting: 3 new BlenderAPI-specific sections
    - Session creation failures
    - 413 Payload Too Large errors
    - Service health checks

  Benefits of Using BlenderAPI

  | Aspect            | GraphQL Approach (OLD)                | BlenderAPI Approach (NEW)    |
  |-------------------|---------------------------------------|------------------------------|
  | Backend Work      | 2 new mutations + polling + DB schema | ✅ ZERO (already exists)     |
  | Timeline          | ~2 weeks backend dev + testing        | ✅ Immediate (ready now)     |
  | Deployment        | New code → QA → staging → prod        | ✅ Already deployed to stage |
  | Testing           | Write new tests                       | ✅ Test scripts included     |
  | Maintenance       | New code to maintain                  | ✅ Already maintained        |
  | Session Cleanup   | Manual implementation                 | ✅ Auto-cleanup (5 min TTL)  |
  | File Size Limit   | Need to define                        | ✅ 100MB (configured)        |
  | Error Handling    | Need to implement                     | ✅ Production-ready          |
  | Progress Tracking | Need to implement                     | ✅ Built-in polling          |

  Technical Implementation

  The mobile app will now:
  1. Upload combined USDZ to GraphQL backend (existing)
  2. Download converted GLB from GraphQL backend (existing)
  3. Create BlenderAPI session → Upload GLB → Generate NavMesh → Download result → Delete session

  Service Class:
  class BlenderAPIService {
    final String baseUrl = 'https://blenderapi.stage.motorenflug.at';

    Future<File> generateNavMesh(File glbFile, String outputPath) async {
      final sessionId = await createSession();
      await uploadGLB(sessionId, glbFile);
      await startNavMeshGeneration(sessionId, basename(glbFile.path));
      await waitForCompletion(sessionId);
      final navmesh = await downloadNavMesh(sessionId, 'navmesh_${basename(glbFile.path)}', outputPath);
      await deleteSession(sessionId);
      return navmesh;
    }
  }

  Backend Team: No Action Required

  ✅ Zero backend development needed
  - BlenderAPI already deployed to stage
  - All endpoints working and tested
  - Test scripts available in microservices repo
  - Production deployment whenever ready

  Next Steps

  1. ✅ Plan complete - All documentation updated
  2. Ready for /speckit.tasks - Generate implementation tasks
  3. Mobile team - Can implement using existing BlenderAPI
  4. Backend team - No action required (monitoring only)

  The feature is now significantly simpler and can be implemented immediately without waiting for backend work!
